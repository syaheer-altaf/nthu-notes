\documentclass[12pt,a4paper]{article}

% ------------------------------------------------------------------
% Core encodings & fonts
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{enumitem}
% Page geometry
\usepackage{geometry}
\geometry{margin=1in}

% Maths & theorems
\usepackage{amsmath,amssymb,amsthm, mathrsfs}
\usepackage{mathtools}
% Algorithms
\usepackage{algorithm}
\usepackage[noend]{algorithmic}
\renewcommand{\algorithmiccomment}[1]{\hfill$\triangleright$ #1}
\newcommand{\CALL}[1]{\textbf{call}~#1}   % helper for “call Proc”

% Graphics, colour, code
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}

% Captions
\usepackage{caption}
\usepackage{subcaption}

% Hyper‑links
\usepackage{hyperref}

% ------------------------------------------------------------------
% Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{claim}{Claim}
\newtheorem{definition}{Definition}
\newenvironment{analysis}[1][Analysis]%
{\begin{proof}[#1]}%
	{\end{proof}}
\begin{document}
	
	\title{Notes on Public-key Cryptography}
	\author{Mohamed Syaheer Altaf}
	\maketitle
	
	Public--or asymmetric--key cryptography is an intriguing approach to encrypting and decrypting plaintext messages that hinges on certain \emph{hard} mathematical problems. Unlike symmetric-key cryptography, public-key cryptography uses a pair of keys: a \textbf{public key}, which is used to encrypt data, and a \textbf{private key}, which is used to decrypt it. In this note, we examine the mathematics underpinning these cryptosystems, drawing on abstract algebra and core concepts from number theory. We then discuss and analyze several foundational algorithms and protocols, including RSA, Rabin, and ElGamal.
	
	\section{Some Mathematical Ideas for Public-key Cryptography}
	For prerequisites, let us recall modular arithmetic, sometimes called \emph{clock arithmetic}. 
	Given an integer \(n \ge 1\), called the \emph{modulus}, two integers \(a\) and \(b\) are said to be \emph{congruent modulo} \(n\) if \(n\) divides their difference; that is,
	\[
	n \mid (a-b),
	\]
	and equivalently,
	\[
	a \equiv b \pmod{n}.
	\]
	This is closely related to the \textbf{Euclidean division lemma}: given integers \(a\) and \(n\), there exist \emph{unique} integers \(m\) and \(b\) such that
	\[
	a = mn + b \qquad \text{with } 0 \le b < |n|.
	\]
	
	This motivates the operation \(a \bmod n = b\), where \(b\) is the remainder when \(a\) is divided by \(n\) thereby giving us the relation \(a \equiv b \pmod{n}\) (note that \(\bmod\) defines a remainder operation, whereas congruence \(\equiv\) defines an equivalence relation).
	We record several useful properties under addition (\(+\)) and multiplication (\(\cdot\)), whose proofs are omitted:
	\begin{itemize}
		\item \(a + b \equiv (a \bmod n) + (b \bmod n) \pmod{n}.\)
		\item \(a \cdot b \equiv (a \bmod n)\cdot (b \bmod n) \pmod{n}.\)
		\item If \(a + b \equiv a + c \pmod{n}\), then \(b \equiv c \pmod{n}.\)
		\item If \(a \cdot b \equiv a \cdot c \pmod{n}\), then \(b \equiv c \pmod{n}\) \textbf{only if} \(a\) is \emph{relatively prime} to \(n\); i.e., \(\gcd(a,n)=1.\)
	\end{itemize}
	
	It is also worthwhile to examine \emph{modular exponentiation}, namely, how to efficiently compute \(a^{m} \bmod n\).
	For instance, to compute \(17^{11} \bmod 35\), a direct evaluation of \(17^{11}\) is impractical: the value is on the order of \(10^{13}\), and computing with such large intermediate numbers is unnecessary.
	However, because we ultimately reduce modulo \(35\), we can repeatedly apply modular reduction throughout the computation---capitalizing on the multiplication property of modular arithmetic.
	
	In this example, we may write
	\[
	17^{11} = 17^{2}\cdot 17^{3}\cdot 17^{3}\cdot 17^{3}.
	\]
	Thus,
	\begin{align*}
		17^{11} \bmod 35
		&= \bigl((289 \bmod 35)\cdot(4913 \bmod 35)\cdot(4913 \bmod 35)\cdot(4913 \bmod 35)\bigr)\bmod 35 \\
		&= (9 \cdot 13 \cdot 13 \cdot 13)\bmod 35 \\
		&= 33.
	\end{align*}
	
	In practice, computers typically use the \emph{repeated-squaring} method: one writes the exponent as a sum of powers of two (e.g., \(11 = 8 + 2 + 1\)) and obtains the needed modular powers by successively squaring and reducing modulo \(n\).
	This achieves the same principle--keeping intermediate values small--while being computationally efficient.
	
	\subsection{Abstract Algebra}
	For this part, we are going to look at several algebraic structures: groups, rings, and fields. For any such structure, one must carefully verify its \emph{axioms} under the relevant operations to determine whether it indeed belongs to the stated class.
	
	\subsubsection{Groups}
	A \textbf{group} is a set \(G\) equipped with a binary operation \(*\)---often denoted by \((G, *)\)---that satisfies the following axioms:
	\begin{enumerate}
		\item \textbf{Closure.} For all \(a,b \in G\), we have \(a*b \in G\).
		\item \textbf{Associativity.} For all \(a,b,c \in G\), \((a*b)*c = a*(b*c)\).
		\item \textbf{Identity.} There exists an element \(e \in G\) such that \(e*a = a*e = a\) for all \(a \in G\).
		\item \textbf{Inverse.} For every \(a \in G\), there exists an element \(a^{-1} \in G\) such that \(a*a^{-1} = a^{-1}*a = e\).
	\end{enumerate}
	\textbf{Note.} \emph{Commutativity} (i.e., \(a*b=b*a\)) is not required. If a group does satisfy commutativity, then it is called an \emph{abelian} group.
	
	\subsubsection{Rings}
	A \textbf{ring} is a set \(R\) equipped with \emph{two} binary operations, \(+\) and \(*\)---often denoted by \((R,+,*)\)---that satisfies the following axioms:
	\begin{enumerate}
		\item \((R,+)\) is an abelian group (in particular, addition is associative and commutative, has an identity \(0\), and every element has an additive inverse).
		\item \((R,*)\) is a semigroup:
		\begin{itemize}
			\item \textbf{Closure.} For all \(a,b \in R\), \(a*b \in R\).
			\item \textbf{Associativity.} For all \(a,b,c \in R\), \((a*b)*c = a*(b*c)\).
		\end{itemize}
		\item \textbf{Distributivity.} For all \(a,b,c \in R\), \(a*(b+c) = a*b + a*c\) and \((b+c)*a = b*a + c*a\).
	\end{enumerate}
	\textbf{Note.} If \(*\) is also commutative, then the structure is called a \emph{commutative ring}. If \(*\) has a multiplicative identity, then it is called a ring \emph{with \(1\)} (or a \emph{unital} ring). In general, elements of a ring need not have multiplicative inverses, and this is consistent with the definition.
	
	\subsubsection{Fields}
	A \textbf{field} \((R,+,*)\) is a \emph{ring} satisfying the additional requirement that \(\bigl(R \setminus \{0\}, *\bigr)\) is an abelian group. Equivalently, every nonzero element of \(R\) has a multiplicative inverse, and multiplication is commutative. In short, a field is a \emph{commutative division ring}. It is also common to denote a field by \(\mathbb{F}\).
	
	For example, \((\mathbb{Z}_4, +, \cdot)\) (with operations taken modulo \(4\)) is not a field because the element \(2\) has no multiplicative inverse modulo \(4\). In contrast, \((\mathbb{Z}_5, +, \cdot)\) (modulo \(5\)) is a field because every element except \(0\) has a multiplicative inverse (see the tables).
	
	% --- Tables for Z_4 ---
	\begin{center}
		\textbf{Addition and multiplication in \(\mathbb{Z}_4\)}\\[4pt]
		
		\[
		\begin{array}{c|cccc}
			+ & 0 & 1 & 2 & 3\\ \hline
			0 & 0 & 1 & 2 & 3\\
			1 & 1 & 2 & 3 & 0\\
			2 & 2 & 3 & 0 & 1\\
			3 & 3 & 0 & 1 & 2
		\end{array}
		\qquad
		\begin{array}{c|cccc}
			\cdot & 0 & 1 & 2 & 3\\ \hline
			0 & 0 & 0 & 0 & 0\\
			1 & 0 & 1 & 2 & 3\\
			2 & 0 & 2 & 0 & 2\\
			3 & 0 & 3 & 2 & 1
		\end{array}
		\]
	\end{center}
	
	% --- Tables for Z_5 ---
	\begin{center}
		\textbf{Addition and multiplication in \(\mathbb{Z}_5\)}\\[4pt]
		
		\[
		\begin{array}{c|ccccc}
			+ & 0 & 1 & 2 & 3 & 4\\ \hline
			0 & 0 & 1 & 2 & 3 & 4\\
			1 & 1 & 2 & 3 & 4 & 0\\
			2 & 2 & 3 & 4 & 0 & 1\\
			3 & 3 & 4 & 0 & 1 & 2\\
			4 & 4 & 0 & 1 & 2 & 3
		\end{array}
		\qquad
		\begin{array}{c|ccccc}
			\cdot & 0 & 1 & 2 & 3 & 4\\ \hline
			0 & 0 & 0 & 0 & 0 & 0\\
			1 & 0 & 1 & 2 & 3 & 4\\
			2 & 0 & 2 & 4 & 1 & 3\\
			3 & 0 & 3 & 1 & 4 & 2\\
			4 & 0 & 4 & 3 & 2 & 1
		\end{array}
		\]
	\end{center}
	
	\paragraph{Finite (Galois) field.}
	By the axioms above, the set of real numbers \(\mathbb{R}\) (and likewise the complex numbers \(\mathbb{C}\)), together with the usual addition and multiplication, forms a field. However, in network security we are often interested in \emph{finite} fields---for instance, \((\mathbb{Z}_5,+,\cdot)\) with arithmetic taken modulo \(5\), which is \(\mathsf{GF}(5)\), where \(\mathsf{GF}\) denotes \emph{Galois field}.
	
	More generally, for a prime \(p\) and a positive integer \(n\), \(\mathsf{GF}(p^n)\) denotes a finite field with \(p^n\) elements. Note that \(\mathsf{GF}(p)\cong (\mathbb{Z}_p,+,\cdot)\) (modulo \(p\)), whereas for \(n>1\), \(\mathsf{GF}(p^n)\ncong (\mathbb{Z}_{p^n},+,\cdot)\) (modulo \(p^n\)). So, how can one construct a Galois field when \(n>1\)? One may do so in the following way:
	\begin{enumerate}
		\item Choose an \textbf{irreducible polynomial} \(P(x)\in \mathbb{Z}_p[x]\) of degree \(n\).
		\item \(\mathsf{GF}(p^n) \cong \mathbb{Z}_p[x]/P.\)
	\end{enumerate}
	Operationally, this means we do polynomial arithmetic over \(\mathbb{Z}_p\) and reduce modulo \(P(x)\); in particular, every element can be represented by a polynomial of degree \(<n\) whose coefficients are in \(\mathbb{Z}_p\). Next, we will look at an example in which the technique used can be applied to the construction of any \(\mathsf{GF}(2^n)\) (i.e., \emph{binary} finite fields).
	
	\medskip
	\noindent\textbf{Example: \(\mathsf{GF}(4)\).}
	To construct \(\mathsf{GF}(4)\), we take \(p=2\) and \(n=2\), and choose the irreducible polynomial
	\[
	P(x)=x^2+x+1 \in \mathbb{Z}_2[x].
	\]
	Then
	\[
	\mathsf{GF}(4)\cong \mathbb{Z}_2[x]/(x^2+x+1),
	\qquad
	\mathsf{GF}(4)=\{0,\;1,\;x,\;x+1\}.
	\]
	In this setting, we may use the reduction rule
	\[
	x^2 \equiv x+1 \pmod{x^2+x+1},
	\]
	because \(x^2+x+1 \equiv 0 \pmod{x^2+x+1}\)---note that addition \((+)\) is in modulo \(2\).
	\medskip
	\noindent\textbf{Polynomial reduction example.}
	Reduce \(x^5+x^3+1\) modulo \(x^2+x+1\) over \(\mathbb{Z}_2\):
	\begin{align*}
		x^5+x^3+1
		&= (x^2+x+1)\,x^3 + {\color{red}(x^4+1)}\\
		&= (x^2+x+1)\,x^3 + (x^2+x+1)\,x^2 + {\color{red}(x^3+x^2+1)}\\
		&= (x^2+x+1)\,x^3 + (x^2+x+1)\,x^2 + (x^2+x+1)\,x + {\color{blue}(x+1)}.
	\end{align*}
	
	Notice that At each iteration, we eliminate the current highest-degree term by subtracting a suitable multiple of \(x^2+x+1\).
	Concretely, if the current polynomial has leading term \(x^d\) with \(d\ge 2\), we multiply the modulus \(x^2+x+1\) by \(x^{d-2}\), which produces a leading term \(x^d\); subtracting (equivalently, adding in \(\mathbb{Z}_2[X]\)) cancels that term and strictly lowers the degree.
	Repeating this step until the degree is \(<2\) yields the remainder, which is unique and is the desired reduction modulo \(x^2+x+1\). Hence,
	\[
	x^5+x^3+1 \equiv x+1 \pmod{x^2+x+1}.
	\]
	
	\medskip
	\noindent\textbf{Tables for \(\mathsf{GF}(4)\).}
	Using the element order \(\{0,1,x,x+1\}\), where addition is coefficient-wise modulo \(2\) and multiplication is reduced modulo \(x^2+x+1\), we obtain:
	\[
	\begin{array}{c|cccc}
		+ & 0 & 1 & x & x+1\\ \hline
		0 & 0 & 1 & x & x+1\\
		1 & 1 & 0 & x+1 & x\\
		x & x & x+1 & 0 & 1\\
		x+1 & x+1 & x & 1 & 0
	\end{array}
	\qquad
	\begin{array}{c|cccc}
		\cdot & 0 & 1 & x & x+1\\ \hline
		0 & 0 & 0 & 0 & 0\\
		1 & 0 & 1 & x & x+1\\
		x & 0 & x & x+1 & 1\\
		x+1 & 0 & x+1 & 1 & x
	\end{array}
	\]
	
	\paragraph{Elliptic curve group.}
	There are two groups that frequently arise in network security:
	\begin{enumerate}
		\item the multiplicative group \(\mathbb{Z}_p^{(\ast)}\) (i.e., the nonzero residues modulo a prime \(p\), under multiplication), and
		\item the additive group of points on an elliptic curve, denoted \((\mathsf{E}(\mathbb{F}), +)\).
	\end{enumerate}
	The set \(\mathsf{E}(\mathbb{F})\) consists of all points \((x,y)\in \mathbb{F}^2\) satisfying a (Weierstrass) elliptic-curve equation, together with a special \emph{point at infinity} \(O\) (which serves as the \emph{additive identity}). In full generality, one may write
	\[
	y^2 + a_1xy + a_3y \;=\; x^3 + a_2x^2 + a_4x + a_6,
	\qquad a_i \in \mathbb{F},
	\]
	with parameters chosen so that the curve is \emph{non-singular} (i.e., it has no cusp or self-intersection). The precise ``simplest'' form of the equation, as well as the cleanest addition formulas, depend on the \emph{characteristic} of the field \(\mathbb{F}\), denoted \(\mathsf{char}(\mathbb{F})\). Recall that \(\mathsf{char}(\mathbb{F})=m\) means the smallest positive integer such that for all \(a\in \mathbb{F}\),
	\[
	\underbrace{a+\cdots+a}_{m\text{ times}}=0,
	\]
	and if no such \(m\) exists, then \(\mathsf{char}(\mathbb{F})=0\). For example, \(\mathsf{char}(\mathbb{R})=0\) whereas \(\mathsf{char}(\mathsf{GF}(2^n))=2\).
	
	\medskip
	\noindent\textbf{Case 1: \(\mathsf{char}(\mathbb{F})\neq 2,3\).}
	In this case, every elliptic curve can be written (after a change of variables) in the short Weierstrass form
	\[
	\mathsf{E}:\quad y^2 = x^3 + ax + b,
	\]
	with the non-singularity condition
	\[
	4a^3 + 27b^2 \neq 0.
	\]
	The group law is defined geometrically by the chord-and-tangent rule; algebraically, it can be computed as follows.
	Let \(P=(x_1,y_1)\) and \(Q=(x_2,y_2)\) be points on \(\mathsf{E}\).
	
	\begin{itemize}
		\item \textbf{Identity.} \(P+O=O+P=P\).
		\item \textbf{Inverse.} \(-P=(x_1,-y_1)\), and \(P+(-P)=O\).
		\item \textbf{Addition (\(P\neq Q\)).} If \(x_1\neq x_2\), define
		\[
		\lambda = \frac{y_2-y_1}{x_2-x_1},\qquad
		x_3 = \lambda^2 - x_1 - x_2,\qquad
		y_3 = \lambda(x_1-x_3)-y_1.
		\]
		Then \(P+Q=(x_3,y_3)\). If \(x_1=x_2\) and \(y_1=-y_2\), then \(P+Q=O\).
		\item \textbf{Doubling (\(P=Q\)).} If \(y_1\neq 0\), define
		\[
		\lambda = \frac{3x_1^2+a}{2y_1},\qquad
		x_3 = \lambda^2 - 2x_1,\qquad
		y_3 = \lambda(x_1-x_3)-y_1,
		\]
		and set \(2P=(x_3,y_3)\). If \(y_1=0\), then \(2P=O\).
	\end{itemize}
	
	\medskip
	\noindent\textbf{Case 2: \(\mathsf{char}(\mathbb{F})=2\).}
	Over fields of characteristic \(2\), elliptic curves used in practice are typically presented in one of two standard forms. The distinction below is often summarized via the \(j\)-invariant: in characteristic \(2\), the case \(j=0\) corresponds to the \emph{supersingular} form (no \(xy\) term), while \(j\neq 0\) corresponds to the \emph{ordinary} form (with an \(xy\) term).
	
	\smallskip
	\noindent\textbf{(a) Ordinary case (\(j\neq 0\)).}
	A common model is
	\[
	\mathsf{E}:\quad y^2 + xy = x^3 + ax^2 + b,
	\qquad a,b\in \mathbb{F},\ \ b\neq 0.
	\]
	For \(P=(x_1,y_1)\in \mathsf{E}(\mathbb{F})\):
	\begin{itemize}
		\item \textbf{Identity.} \(P+O=P\).
		\item \textbf{Inverse.} \(-P=(x_1,\,y_1+x_1)\).
		\item \textbf{Addition (\(P\neq Q\)).} For \(Q=(x_2,y_2)\) with \(x_1\neq x_2\), define
		\[
		\lambda = \frac{y_1+y_2}{x_1+x_2},\qquad
		x_3 = \lambda^2+\lambda+x_1+x_2+a,\qquad
		y_3 = \lambda(x_1+x_3)+x_3+y_1.
		\]
		Then \(P+Q=(x_3,y_3)\). If \(x_1=x_2\) and \(y_1+y_2=x_1\), then \(P+Q=O\).
		\item \textbf{Doubling (\(P=Q\)).} If \(x_1\neq 0\), define
		\[
		\lambda = x_1 + \frac{y_1}{x_1},\qquad
		x_3 = \lambda^2+\lambda+a,\qquad
		y_3 = x_1^2 + (\lambda+1)x_3,
		\]
		and set \(2P=(x_3,y_3)\). If \(x_1=0\), then \(2P=O\).
	\end{itemize}
	
	\smallskip
	\noindent\textbf{(b) Supersingular case (\(j=0\)).}
	A common model is
	\[
	\mathsf{E}:\quad y^2 + ay = x^3 + bx + c,
	\qquad a,b,c\in \mathbb{F},\ \ a\neq 0.
	\]
	For \(P=(x_1,y_1)\in \mathsf{E}(\mathbb{F})\):
	\begin{itemize}
		\item \textbf{Identity.} \(P+O=P\).
		\item \textbf{Inverse.} \(-P=(x_1,\,y_1+a)\).
		\item \textbf{Addition (\(P\neq Q\)).} For \(Q=(x_2,y_2)\) with \(x_1\neq x_2\), define
		\[
		\lambda = \frac{y_1+y_2}{x_1+x_2},\qquad
		x_3 = \lambda^2 + x_1 + x_2,\qquad
		y_3 = \lambda(x_1+x_3) + y_1 + a.
		\]
		Then \(P+Q=(x_3,y_3)\). If \(x_1=x_2\) and \(y_1+y_2=a\), then \(P+Q=O\).
		\item \textbf{Doubling (\(P=Q\)).} Define
		\[
		\lambda = \frac{x_1^2 + b}{a},\qquad
		x_3 = \lambda^2,\qquad
		y_3 = \lambda(x_1+x_3) + y_1 + a,
		\]
		and set \(2P=(x_3,y_3)\).
	\end{itemize}
	
	\subsection{Number Theory}
	First, we look at some elementary number-theoretic concepts which can be extended to finite fields \(\mathsf{GF}(p^n)\), where \(p\) is prime and \(n\) is an integer larger than one.
	
	\begin{theorem}[Bézout's Identity]
		Let \(a,b\in \mathbb{Z}\) be integers, not both zero, and let \(d=\gcd(a,b)\).
		Then there exist integers \(x,y\in \mathbb{Z}\) such that
		\[
		ax+by=d.
		\]
		Moreover, \(d\) is the \emph{smallest positive} integer that can be written in the form \(ax+by\).
		\label{thm:bezout}
	\end{theorem}
	
	\begin{proof}
		Without loss of generality, assume \((a,b)\neq (0,0)\). Consider the set
		\[
		S=\{\,ax+by \;:\; x,y\in \mathbb{Z},\ ax+by>0\,\}.
		\]
		This set is nonempty: if \(a\neq 0\), choose \(x=\operatorname{sgn}(a)\) and \(y=0\), giving \(|a|\in S\); similarly if \(a=0\) then \(b\neq 0\) and \(|b|\in S\).
		
		By the Well-Ordering Principle, \(S\) has a smallest element; call it \(d\). By definition, there exist integers \(x_0,y_0\) such that
		\[
		d=ax_0+by_0.
		\]
		
		We first show that \(d\) divides both \(a\) and \(b\). Apply the division algorithm to \(a\) with divisor \(d\): there exist integers \(q\) and \(r\) such that
		\[
		a=qd+r,\qquad 0\le r<d.
		\]
		Substitute \(d=ax_0+by_0\) into the expression for \(r\):
		\[
		r=a-qd
		=a-q(ax_0+by_0)
		=a(1-qx_0)+b(-qy_0).
		\]
		Hence \(r\) is an integer linear combination of \(a\) and \(b\). Also, \(r\ge 0\) by the division algorithm. If \(r>0\), then \(r\in S\), contradicting the minimality of \(d\). Therefore \(r=0\), so \(d\mid a\). The same argument applied to \(b\) shows \(d\mid b\).
		
		Next, we show that \(d\) is the greatest common divisor. Let \(c\) be any common divisor of \(a\) and \(b\). Then \(c\mid ax\) and \(c\mid by\) for all integers \(x,y\), and thus \(c\mid (ax+by)\). In particular, \(c\mid d=ax_0+by_0\). Therefore every common divisor of \(a\) and \(b\) divides \(d\), and since \(d\) itself is a common divisor, we conclude \(d=\gcd(a,b)\).
		
		Finally, since \(d\in S\) is the smallest positive element of the form \(ax+by\), it is indeed the smallest positive integer representable as an integer linear combination of \(a\) and \(b\).
	\end{proof}
	
	\begin{theorem}[Euclid's Lemma]
		For two integers \(k\) and \(l\), if their product \(k\cdot l\) is divisible by a prime \(p\), then either \(p\mid k\) or \(p\mid l\) (or both).
		\label{thm:euclid_lemma}
	\end{theorem}
	
	\begin{proof}
		In fact, we prove a slightly stronger statement (which will immediately imply the theorem). Also, without loss of generality, we may assume all numbers involved are positive: divisibility is invariant under changing signs.
		
		\medskip
		\noindent\textbf{Stronger claim.} If \(n\mid kl\) and \(\gcd(n,k)=1\), then \(n\mid l\).
		
		\medskip
		\noindent Suppose \(n\mid kl\) and \(\gcd(n,k)=1\). Since \(\gcd(n,k)=1\), by Bézout's identity there exist integers \(u\) and \(v\) such that
		\[
		un + vk = 1.
		\]
		Multiplying both sides by \(l\) gives
		\[
		u(nl) + v(kl) = l.
		\]
		Now, \(n\mid nl\) is immediate. Also, since \(n\mid kl\) by assumption, we have \(n\mid v(kl)\) as well. Therefore, \(n\) divides the sum \(u(nl) + v(kl)\), which equals \(l\). Hence \(n\mid l\), proving the stronger claim.
		
		\medskip
		\noindent To obtain Euclid's Lemma, let \(n=p\) be a prime. If \(p\mid kl\) and \(p\nmid k\), then \(\gcd(p,k)=1\) (a prime has no common divisor with \(k\) other than \(1\) unless it divides \(k\)). By the stronger claim, \(p\mid l\). Equivalently, whenever \(p\mid kl\), we must have \(p\mid k\) or \(p\mid l\).
	\end{proof}
	
	\begin{theorem}[Prime Factorization Theorem (Fundamental Theorem of Arithmetic)]
		Every integer \(n>1\) can be written as a product of prime powers
		\[
		n \;=\; p_{1}^{\alpha_1}\, p_{2}^{\alpha_2}\cdots p_{k}^{\alpha_k},
		\]
		where \(p_1<p_2<\dots<p_k\) are primes and \(\alpha_i\) are positive integers. Moreover, this representation is unique up to the ordering of the prime factors.
		
		For example, \(2=2^1\), \(4459=7^3\cdot 13^1\), and \(30=2^1\cdot 3^1\cdot 5^1\).
		\label{thm:fundamental_arithmetic}
	\end{theorem}
	\begin{proof}
		We prove both \emph{existence} and \emph{uniqueness}.
		
		\medskip
		\noindent\textbf{Existence.}
		We use strong induction on \(n\ge 2\).
		For the base case \(n=2\), the claim holds since \(2\) is prime.
		
		Now assume as the induction hypothesis that every integer \(m\) with \(2\le m < n\) can be written as a product of primes. We consider two cases:
		\begin{enumerate}
			\item If \(n\) is prime, then \(n\) is already a product of primes (namely itself), so we are done.
			\item If \(n\) is composite, then \(n=ab\) for some integers \(a,b\) with \(1<a<n\) and \(1<b<n\). By the induction hypothesis, both \(a\) and \(b\) can be written as products of primes. Multiplying those two prime factorizations together expresses \(n\) as a product of primes as well.
		\end{enumerate}
		This completes the induction and proves existence.
		
		\medskip
		\noindent\textbf{Uniqueness.}
		Suppose \(n>1\) can be written as a product of primes in two ways (allowing repeated primes, so that exponents are implicit):
		\[
		n \;=\; p_1p_2\cdots p_k \;=\; q_1q_2\cdots q_\ell,
		\]
		where each \(p_i\) and each \(q_j\) is prime.
		
		We show that the two lists of primes must agree up to reordering. Since \(p_1 \mid n\) and \(n=q_1q_2\cdots q_\ell\), we have \(p_1 \mid (q_1q_2\cdots q_\ell)\). By Euclid's Lemma, \(p_1\) divides \(q_j\) for some \(j\). Because \(q_j\) is prime, this forces \(p_1=q_j\).
		
		Cancel this common prime factor from both sides. Concretely, after reordering the \(q\)'s if necessary, we may assume \(p_1=q_1\), and then divide both sides by \(p_1\) to obtain
		\[
		\frac{n}{p_1} \;=\; p_2\cdots p_k \;=\; q_2\cdots q_\ell.
		\]
		Now repeat the same argument with \(p_2\), then \(p_3\), and so on. Each step cancels one prime factor from the left and one prime factor from the right. This process cannot terminate early on one side: if, say, \(k<\ell\), then after canceling \(k\) primes we would obtain
		\[
		1 = q_{k+1}\cdots q_\ell,
		\]
		which is impossible because the right-hand side is a product of primes and hence at least \(2\). Therefore \(k=\ell\), and after reordering, we must have \(p_i=q_i\) for all \(i\).
		
		Finally, grouping equal primes together yields the prime-power form
		\(
		n = p_1^{\alpha_1}\cdots p_k^{\alpha_k}
		\),
		and the argument above shows that both the primes and their exponents are uniquely determined.
	\end{proof}
	
	Now, we look at an important algorithm in number theory that efficiently computes the greatest common divisor of a pair of integers.
	
	\begin{algorithm}[H]
		\caption{\textsc{Euclid's Algorithm}}
		\label{alg:euclid_algo}
		\textbf{Input:} Non-negative integers \(a\) and \(b\). Without loss of generality, assume \(a \ge b\).\\
		\textbf{Output:} \(\gcd(a,b)\).
		\begin{algorithmic}[1]
			\STATE Let \(r_0 \gets a\) and \(r_1 \gets b\).
			\STATE For \(i=1,2,\dots\), apply the division algorithm (i.e., \(x = yq + r \quad (0 \le r < y)\)) to write
			\[
			r_{i-1} = q_i r_i + r_{i+1} \qquad \text{with } 0 \le r_{i+1} < r_i,
			\]
			and continue until \(r_{i+1}=0\).
			\STATE Output the last nonzero remainder \(r_i\).
		\end{algorithmic}
	\end{algorithm}
	\begin{analysis}
		We first show that the algorithm terminates. At each step we have
		\[
		0 \le r_{i+1} < r_i,
		\]
		so the sequence \(r_1, r_2, \dots\) is a strictly decreasing sequence of nonnegative integers. Such a sequence cannot decrease indefinitely, hence there exists some step \(T\) such that \(r_{T+1}=0\). In particular, the algorithm must terminate.
		
		\medskip
		\noindent\textbf{Correctness.}
		Assume the algorithm terminates at step \(T\), so \(r_{T+1}=0\) and \(r_T\neq 0\). We claim that the algorithm outputs \(\gcd(a,b)\), i.e., \(r_T=\gcd(a,b)\).
		
		The key fact is the following lemma.
		
		\begin{lemma}
			If \(j=kq+r\) for integers \(j,k,q,r\), then \(\gcd(j,k)=\gcd(k,r)\).
			\label{thm:gcd_equiv}
		\end{lemma}
		
		\begin{proof}
			Let \(m=\gcd(j,k)\) and \(n=\gcd(k,r)\).
			
			First, since \(m\mid j\) and \(m\mid k\), we have \(m\mid (j-kq =r)\). Thus \(m\) divides both \(k\) and \(r\), so \(m\) is a common divisor of \(k\) and \(r\). Hence \(m\le n\).
			
			Conversely, since \(n\mid k\) and \(n\mid r\), we have \(n\mid (kq+r =j)\). Thus \(n\) divides both \(j\) and \(k\), so \(n\) is a common divisor of \(j\) and \(k\). Hence \(n\le m\).
			
			Therefore \(m=n\), i.e., \(\gcd(j,k)=\gcd(k,r)\).
		\end{proof}
		
		We now apply the lemma to Euclid's Algorithm. By construction, at each iteration we have
		\[
		r_{i-1} = q_i r_i + r_{i+1}.
		\]
		By the lemma (with \(j=r_{i-1}\), \(k=r_i\), and \(r=r_{i+1}\)),
		\[
		\gcd(r_{i-1},r_i)=\gcd(r_i,r_{i+1}) \qquad \text{for all } i\ge 1.
		\]
		Chaining these equalities yields
		\[
		\gcd(r_0,r_1)=\gcd(r_1,r_2)=\cdots=\gcd(r_T,r_{T+1}).
		\]
		Since \(r_{T+1}=0\), we have \(\gcd(r_T,0)=r_T\). Hence
		\[
		\gcd(a,b)=\gcd(r_0,r_1)=\gcd(r_T,0)=r_T.
		\]
		Therefore the last nonzero remainder \(r_T\) output by the algorithm is exactly \(\gcd(a,b)\), proving correctness.
	\end{analysis}
	
	To give an example, let us find the \(\gcd(331, 277)\) using Algorithm~\ref{alg:euclid_algo}.
	\begin{align*}
		{\color{red}331} &= {\color{red}277} \cdot 1 + {\color{blue}54}\\
		{\color{red}277} &= {\color{red}54} \cdot 5 + {\color{blue}7}\\
		{\color{red}54} &= {\color{red}7} \cdot 7 + {\color{blue}5}\\
		{\color{red}7} &= {\color{red}5} \cdot 1 + {\color{blue}2}\\
		{\color{red}5} &= {\color{red}2} \cdot 2 + {\color{blue}1}\\
		{\color{red}2} &= {\color{red}1} \cdot 2 + {\color{blue}0}.
	\end{align*}
	
	Thus, \(\gcd(331, 277) = 1\). 
	
	Algorithm~\ref{alg:euclid_algo} can be applied in \(\mathbb{Z}_2[x]\), which is usually the main case of interest in network security.
	
	\textbf{Example.} Find \(\gcd\bigl(x^8+x^4+x^3+x+1,\; x^7+x^4+x^2+1\bigr)\). Applying Euclid's algorithm in \(\mathbb{Z}_2[x]\), we obtain
	\begin{align*}
		{\color{red}x^8+x^4+x^3+x+1}
		&= {\color{red}(x^7+x^4+x^2+1)}\cdot x + {\color{blue}(x^5+x^4+1)}.
	\end{align*}
	Now, we divide \(x^7+x^4+x^2+1\) by \(x^5+x^4+1\). We carry out the long division term-by-term while ensuring the remainder degree strictly decreases each step:
	\begin{align*}
		{\color{red}x^7+x^4+x^2+1}
		&= {\color{red}(x^5+x^4+1)}\cdot x^2 + (x^6+x^4+1)\\
		&= {\color{red}(x^5+x^4+1)}\cdot x^2 + {\color{red}(x^5+x^4+1)}\cdot x + (x^5+x^4+x+1)\\
		&= {\color{red}(x^5+x^4+1)}\cdot x^2 + {\color{red}(x^5+x^4+1)}\cdot x + {\color{red}(x^5+x^4+1)}\cdot 1 + x\\
		&= {\color{red}(x^5+x^4+1)}\cdot (x^2+x+1) + {\color{blue}x}.
	\end{align*}
	
	Next, we divide \((x^5+x^4+1)\) by \(x\):
	\begin{align*}
		{\color{red}x^5+x^4+1}
		&= {\color{red}x}\cdot x^4 + (x^4+1)\\
		&= {\color{red}x}\cdot x^4 + \bigl({\color{red}x}\cdot x^3 + 1\bigr)\\
		&= {\color{red}x}\cdot (x^4+x^3) + {\color{blue}1}.
	\end{align*}
	Finally,
	\[
	{\color{red}x} = {\color{red}1}\cdot x + {\color{blue}0}.
	\]
	Hence, the last non-zero remainder is \(1\), and therefore
	\[
	\gcd\bigl(x^8+x^4+x^3+x+1,\; x^7+x^4+x^2+1\bigr)=1.
	\]
	
	Euclid's algorithm can be \emph{extended} to compute the coefficients of Bézout's identity (i.e., directly finding the \(x\) and \(y\) in the equation \(a \cdot x + b \cdot y = \gcd(a, b)\)).
	
	\begin{algorithm}[H]
		\caption{\textsc{Extended Euclidean Algorithm}}
		\label{alg:ext_euclid_algo}
		\textbf{Input:} Non-negative integers \(a\) and \(b\). Without loss of generality, assume \(a \ge b\).\\
		\textbf{Output:} Integers \(s\) and \(t\) such that \(as+bt=\gcd(a,b)\).
		\begin{algorithmic}[1]
			\STATE Let \(r_0 \gets a\) and \(r_1 \gets b\).
			\STATE Let \(s_0 \gets 1\) and \(s_1 \gets 0\).
			\STATE Let \(t_0 \gets 0\) and \(t_1 \gets 1\).
			\STATE For \(i=1,2,3,\dots\), apply the division algorithm to write
			\[
			r_{i-1} = q_i r_i + r_{i+1} \qquad \text{with } 0 \le r_{i+1} < r_i,
			\]
			and update
			\[
			s_{i+1} = s_{i-1} - q_i s_i,
			\qquad
			t_{i+1} = t_{i-1} - q_i t_i,
			\]
			until \(r_{i+1}=0\).
			\STATE Output \(s_i\) and \(t_i\), where \(i\) is the index of the last nonzero remainder \(r_i\).
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.}
		From Algorithm~\ref{alg:euclid_algo}, we already know that if the last nonzero remainder is \(r_T\), then
		\[
		r_T=\gcd(a,b).
		\]
		It remains to show that the algorithm outputs coefficients \(s_T\) and \(t_T\) satisfying Bézout's identity
		\[
		as_T+bt_T=r_T.
		\]
		
		\medskip
		\noindent\textbf{Claim.} For every index \(i\ge 0\), the values \(r_i, s_i, t_i\) maintained by the algorithm satisfy
		\[
		r_i = as_i + bt_i.
		\]
		In particular, at termination this gives \(r_T = as_T + bt_T\), so the output \((s_T,t_T)\) is correct.
		
		\medskip
		\noindent\emph{Proof of the claim (by induction on \(i\)).}
		For the base cases,
		\[
		r_0=a = a\cdot 1 + b\cdot 0 = as_0 + bt_0,
		\qquad
		r_1=b = a\cdot 0 + b\cdot 1 = as_1 + bt_1.
		\]
		Assume the identity holds for indices \(i-1\) and \(i\), i.e.,
		\[
		r_{i-1}=as_{i-1}+bt_{i-1}
		\qquad\text{and}\qquad
		r_i=as_i+bt_i.
		\]
		At step \(i\), the algorithm computes
		\[
		r_{i+1}=r_{i-1}-q_i r_i,\qquad
		s_{i+1}=s_{i-1}-q_i s_i,\qquad
		t_{i+1}=t_{i-1}-q_i t_i.
		\]
		Substituting the induction hypothesis into the recurrence for \(r_{i+1}\) gives
		\begin{align*}
			r_{i+1}
			&= (as_{i-1}+bt_{i-1}) - q_i(as_i+bt_i)\\
			&= a(s_{i-1}-q_i s_i) + b(t_{i-1}-q_i t_i)\\
			&= as_{i+1} + bt_{i+1}.
		\end{align*}
		Thus the identity holds for \(i+1\), completing the induction.
		
		\medskip
		\noindent Therefore, when the algorithm terminates with \(r_{T+1}=0\) and \(r_T\neq 0\), we have
		\[
		\gcd(a,b)=r_T = as_T + bt_T,
		\]
		so the returned \(s_T\) and \(t_T\) are indeed valid Bézout coefficients.
	\end{analysis}
	
	We particularly use the extended Euclidean algorithm to find multiplicative inverses of elements in a finite field.
	
	\textbf{Example.} In \(\mathbb{Z}_{1021}\) (which is \(\cong \mathsf{GF}(1021)\) since \(1021\) is prime), compute the multiplicative inverse of the element \(453\). Applying Algorithm~\ref{alg:ext_euclid_algo} with \(a=1021\) and \(b=453\), we obtain the following sequence:
	
	\begin{table}[H]
		\centering
		\begin{tabular}{c|c|c|c|c}
			\textbf{index \(i\)} & {\color{red}\textbf{\(q_{i-1}\)}} & \textbf{\(r_i\)} & \textbf{\(s_i\)} & \textbf{\(t_i\)}\\ \hline
			0 & -- & 1021 & 1 & 0\\
			1 & -- & 453  & 0 & 1\\
			2 & 2  & 115  & 1 & -2\\
			3 & 3  & 108  & -3 & 7\\
			4 & 1  & 7    & 4 & -9\\
			5 & 15 & 3    & -63 & 142\\
			6 & 2  & {\color{red}1}    & {\color{red}130} & {\color{red}-293}\\
			7 & 3  & {\color{blue}0}    & -- & --\\
		\end{tabular}
	\end{table}
	
	Since the last non-zero remainder is \(r_6=1\), we have \(\gcd(1021,453)=1\). Moreover, the row \(i=6\) gives the Bézout relation
	\[
	1021\cdot {\color{red}130} + 453\cdot{\color{red}(-293)} = {\color{red}1}.
	\]
	Reducing modulo \(1021\), this becomes
	\[
	453\cdot(-293) \equiv 1 \pmod{1021},
	\]
	so the multiplicative inverse of \(453\) in \(\mathbb{Z}_{1021}\) is
	\[
	453^{-1} \equiv -293 \equiv 1021-293 = 728 \pmod{1021}.
	\]
	
	\noindent Here is another example involving \(\mathsf{GF}(256)\).
	
	\textbf{Example.} Consider the field \(\mathsf{GF}(2^8)\) with irreducible polynomial
	\[
	P(x)=x^8+x^4+x^3+x+1.
	\]
	Find the multiplicative inverse of
	\[
	Q(x)=x^7+x^4+x^2+1
	\]
	in \(\mathsf{GF}(256)\) (i.e., modulo \(P(x)\)). We apply the extended Euclidean algorithm in \(\mathbb{Z}_2[x]\). Since coefficients are taken modulo \(2\), subtraction and addition coincide, so the update rules become
	\begin{align*}
		s_{i+1} &= s_{i-1} \oplus q_i s_i,\\
		t_{i+1} &= t_{i-1} \oplus q_i t_i.
	\end{align*}
	
	It follows that:
	\begin{table}[H]
		\centering
		\begin{tabular}{c|c|c|c|c}
			\textbf{index \(i\)} & {\color{red}\textbf{\(q_{i-1}\)}} & \textbf{\(r_i\)} & \textbf{\(s_i\)} & \textbf{\(t_i\)}\\ \hline
			0 & -- & \(P(x)\) & \(1\) & \(0\)\\
			1 & -- & \(Q(x)\) & \(0\) & \(1\)\\
			2 & \(x\) & \(x^5+x^4+1\) & \(1\) & \(x\)\\
			3 & \(x^2+x+1\) & \(x\) & \(x^2+x+1\) & \(x^3+x^2+x+1\)\\
			4 & \(x^4+x^3\) & {\color{red}\(1\)} & {\color{red}\(x^6+x^3+1\)} & {\color{red}\(x^7+x^3+x\)}\\
			5 & \(x\) & {\color{blue}\(0\)} & -- & --\\
		\end{tabular}
	\end{table}
	
	Since the last nonzero remainder is \(1\), we have \(\gcd(P(x),Q(x))=1\). From the row where \(r_i=1\) (i.e., \(i=4\)), we get
	\[
	P(x)\cdot {\color{red}(x^6+x^3+1)}\;\oplus\; Q(x)\cdot {\color{red}(x^7+x^3+x)} \;=\; {\color{red}1}.
	\]
	Reducing modulo \(P(x)\) eliminates the first term, and we obtain
	\[
	Q(x)\cdot (x^7+x^3+x)\equiv 1 \pmod{P(x)}.
	\]
	Hence, the multiplicative inverse of \(Q(x)\) in \(\mathsf{GF}(256)\) is
	\[
	Q(x)^{-1} \equiv x^7+x^3+x \pmod{P(x)}.
	\]
	
	We study more results from number theory before applying them appropriately to public-key cryptography.
	
	\begin{theorem}[Chinese Remainder Theorem]
		Let \(n_1,n_2,\dots,n_\ell\) be integers greater than \(1\), and let \(N=\prod_{i=1}^{\ell} n_i\). If the \(n_i\) are pairwise coprime (i.e., \(\gcd(n_i,n_j)=1\) for all \(i<j\)), then for any residues \(r_1,r_2,\dots,r_\ell\), the system of congruences
		\begin{align*}
			x &\equiv r_1 \pmod{n_1}\\
			x &\equiv r_2 \pmod{n_2}\\
			&\vdots\\
			x &\equiv r_\ell \pmod{n_\ell}
		\end{align*}
		has a solution. Moreover, if \(x_1\) and \(x_2\) are two solutions, then \(x_1 \equiv x_2 \pmod{N}\) (equivalently, the solution is unique modulo \(N\)).
		\label{thm:chinese_remainder}
	\end{theorem}
	
	\begin{proof}
		We prove existence constructively by writing down an explicit solution. For each \(i\), define
		\[
		N_i := \frac{N}{n_i} = \prod_{j\ne i} n_j.
		\]
		Since the moduli are pairwise coprime, we have \(\gcd(N_i,n_i)=1\). Hence, by Bézout's identity there exist integers \(u_i\) and \(v_i\) such that
		\[
		u_i N_i + v_i n_i = 1.
		\]
		Reducing both sides modulo \(n_i\) yields
		\[
		u_i N_i \equiv 1 \pmod{n_i}.
		\]
		(Concretely, \(u_i\) can be computed using Algorithm~\ref{alg:ext_euclid_algo} applied to \(N_i\) and \(n_i\).)
		
		Now define
		\[
		x := \sum_{i=1}^{\ell} r_i \, u_i \, N_i.
		\]
		We claim that this \(x\) satisfies all congruences. Fix an index \(k\in\{1,\dots,\ell\}\). Consider \(x \bmod n_k\). For any \(i\neq k\), the factor \(N_i\) contains \(n_k\), so \(N_i \equiv 0 \pmod{n_k}\). Therefore, modulo \(n_k\) all terms in the sum vanish except the \(i=k\) term:
		\[
		x \equiv r_k\, u_k\, N_k \pmod{n_k}.
		\]
		Using \(u_k N_k \equiv 1 \pmod{n_k}\), we obtain
		\[
		x \equiv r_k \pmod{n_k},
		\]
		as desired. This proves existence.
		
		For uniqueness modulo \(N\), suppose \(x_1\) and \(x_2\) are two solutions. Then for every \(i\),
		\[
		x_1 \equiv x_2 \pmod{n_i}
		\quad\Longrightarrow\quad
		n_i \mid (x_1-x_2).
		\]
		Since the \(n_i\) are pairwise coprime, their product \(N=\prod_i n_i\) also divides \(x_1-x_2\). Hence,
		\[
		x_1 \equiv x_2 \pmod{N},
		\]
		which proves the solution is unique modulo \(N\).
	\end{proof}
	
	\textbf{Example.} Say we want to find \(x\) satisfying
	\begin{align*}
		x &\equiv 2 \pmod{3}\\
		x &\equiv 1 \pmod{4}\\
		x &\equiv 7 \pmod{11}.
	\end{align*}
	First, note that the moduli \(3,4,11\) are pairwise coprime. Moreover,
	\[
	N = 3\cdot 4\cdot 11 = 132.
	\]
	Following the constructive proof of Theorem~\ref{thm:chinese_remainder}, we define
	\[
	N_1=\frac{N}{3}=44,\qquad N_2=\frac{N}{4}=33,\qquad N_3=\frac{N}{11}=12.
	\]
	We then compute \(u_i\) such that \(u_iN_i \equiv 1 \pmod{n_i}\), i.e., \(u_iN_i+v_in_i=1\), via Algorithm~\ref{alg:ext_euclid_algo}:
	\begin{align*}
		u_1\cdot 44 + v_1\cdot 3 &= 1 \qquad &&\Rightarrow\ u_1=2,\\
		u_2\cdot 33 + v_2\cdot 4 &= 1 \qquad &&\Rightarrow\ u_2=1,\\
		u_3\cdot 12 + v_3\cdot 11 &= 1 \qquad &&\Rightarrow\ u_3=1.
	\end{align*}
	
	\noindent The solution is then constructed as
	\[
	x \equiv r_1u_1N_1 + r_2u_2N_2 + r_3u_3N_3 \pmod{N}.
	\]
	Substituting \(r_1=2\), \(r_2=1\), \(r_3=7\) gives
	\begin{align*}
		x &\equiv 2\cdot 2\cdot 44 \;+\; 1\cdot 1\cdot 33 \;+\; 7\cdot 1\cdot 12 \pmod{132}\\
		&= 176 + 33 + 84\\
		&= 293\\
		&\equiv 29 \pmod{132}.
	\end{align*}
	Therefore, the solutions are exactly \(x = 29 + 132k\) for arbitrary integers \(k\).
	
	\begin{lemma}
		Let \(p\) and \(q\) be coprime. If \(x \equiv y \pmod p\) and \(x \equiv y \pmod q\), then \(x \equiv y \pmod{pq}\).
		\label{lemma:crt_consequence}
	\end{lemma}
	\begin{proof}
		Consider the system of congruences in the unknown \(z\):
		\[
		z \equiv y \pmod p,
		\qquad
		z \equiv y \pmod q.
		\]
		Clearly, \(z=y\) is a solution. Also, \(z=x\) is a solution by assumption.
		
		Since \(\gcd(p,q)=1\), the Chinese Remainder Theorem says that the solution to this system is \emph{unique modulo \(pq\)}. Therefore, any two solutions must be congruent modulo \(pq\). In particular,
		\[
		x \equiv y \pmod{pq},
		\]
		as required.
	\end{proof}
	
	\begin{definition}[Euler Totient Function]
		The Euler totient function \(\phi\) counts the positive integers less than \(n\) that are coprime to \(n\). In other words, for a given \(n\ge 1\),
		\[
		\phi(n) = \Bigl| \{\,x : 1 \le x < n,\ \gcd(x,n)=1\,\} \Bigr|.
		\]
		For example, \(\phi(5)=|\{1,2,3,4\}|=4\) and \(\phi(6)=|\{1,5\}|=2\).
		\label{def:euler_totient_function}
	\end{definition}
	
	\begin{claim}[Properties of \(\phi\)]
		The Euler totient function satisfies the following properties.
		\begin{itemize}
			\item For any prime \(p\) and any integer \(\alpha \ge 1\), we have
			\[
			\phi(p^\alpha) = p^{\alpha-1}(p-1).
			\]
			\item For any integers \(m,n\) such that \(\gcd(m,n)=1\), we have
			\[
			\phi(mn)=\phi(m)\phi(n).
			\]
		\end{itemize}
		Following these properties, we immediately obtain
		\[
		\phi(pq)=(p-1)(q-1)\quad \text{for primes } p,q.
		\]
		\label{claim:totient_prop}
	\end{claim}
	
	\begin{proof}
		\textbf{First property of \(\phi\).}
		Let \(p\) be prime and \(\alpha\ge 1\). Consider the integers \(x\) with \(1\le x < p^\alpha\). Such an \(x\) is \emph{not} coprime to \(p^\alpha\) precisely when \(p\mid x\) (since the only prime divisor of \(p^\alpha\) is \(p\)). Hence, the integers \(x\) in \(\{1,2,\dots,p^\alpha-1\}\) that fail to be coprime to \(p^\alpha\) are exactly the multiples of \(p\):
		\[
		p,\ 2p,\ 3p,\ \dots,\ (p^{\alpha-1}-1)p.
		\]
		There are \(p^{\alpha-1}-1\) such multiples. Since there are \(p^\alpha-1\) total integers in \(\{1,\dots,p^\alpha-1\}\), it follows that
		\[
		\phi(p^\alpha)=(p^\alpha-1) - (p^{\alpha-1}-1) = p^\alpha - p^{\alpha-1} = p^{\alpha-1}(p-1).
		\]
		
		\medskip
		\noindent\textbf{Second property of \(\phi\).}
		Assume \(\gcd(m,n)=1\). We prove that \(\phi(mn)=\phi(m)\phi(n)\) by giving a direct counting argument.
		
		Let
		\[
		A=\{\,a: 1\le a < m,\ \gcd(a,m)=1\,\},\qquad
		B=\{\,b: 1\le b < n,\ \gcd(b,n)=1\,\}.
		\]
		By definition, \(|A|=\phi(m)\) and \(|B|=\phi(n)\).
		
		Now consider the set
		\[
		C=\{\,x: 1\le x < mn,\ \gcd(x,mn)=1\,\},
		\]
		so that \(|C|=\phi(mn)\). We will relate \(C\) to pairs in \(A\times B\) using the Chinese Remainder Theorem (see Theorem~\ref{thm:chinese_remainder}).
		
		\medskip
		\noindent\emph{Step 1:}
		For any integer \(x\),
		\[
		\gcd(x,mn)=1 \quad \Longleftrightarrow \quad \gcd(x,m)=1 \text{ and } \gcd(x,n)=1.
		\]
		Indeed, if \(\gcd(x,mn)=1\), then \(x\) shares no common prime factor with \(mn\), so it shares none with \(m\) or with \(n\). Conversely, if \(\gcd(x,m)=\gcd(x,n)=1\), then \(x\) shares no prime factor with either \(m\) or \(n\), hence shares none with their product \(mn\), so \(\gcd(x,mn)=1\).
		
		\medskip
		\noindent\emph{Step 2:}
		For each \(x\in C\), define the pair
		\[
		(a,b) := (x \bmod m,\ x \bmod n).
		\]
		By Step 1, \(x\in C\) implies \(\gcd(x,m)=1\) and \(\gcd(x,n)=1\). This means \(a\in A\) and \(b\in B\). Hence we obtain a map \(f:C\to A\times B\).
		
		Conversely, take any pair \((a,b)\in A\times B\). Since \(\gcd(m,n)=1\), the Chinese Remainder Theorem guarantees there exists a solution \(x\) to
		\[
		x\equiv a \pmod m,\qquad x\equiv b \pmod n,
		\]
		and moreover this solution is unique modulo \(mn\). Choosing the unique representative \(x\) with \(1\le x < mn\), we get an element \(x\in C\) (again by Step 1, since \(\gcd(a,m)=\gcd(b,n)=1\) implies \(\gcd(x,m)=\gcd(x,n)=1\)). This gives an inverse mapping from \(A\times B\) back to \(C\).
		
		Therefore, \(C\) and \(A\times B\) have the same number of elements:
		\[
		|C| = |A\times B| = |A|\cdot |B| = \phi(m)\phi(n).
		\]
		That is, \(\phi(mn)=\phi(m)\phi(n)\).
	\end{proof}
	
	\paragraph{Note.}
	It will be convenient to define
	\[
	\mathbb{Z}_n^{(*)} := \{\,x : 1 \le x < n,\ \gcd(x,n)=1\,\}.
	\]
	Observe that \(\mathbb{Z}_n^{(*)}\) forms a group under multiplication modulo \(n\), and moreover
	\[
	\phi(n)=\bigl|\mathbb{Z}_n^{(*)}\bigr|.
	\]
	For example,
	\[
	\mathbb{Z}_{12}^{(*)}=\{1,5,7,11\}.
	\]
	
	Now, we have the following important results in number theory. Their proofs are omitted here due to being out of scope.
	
	\begin{theorem}[Fermat's Little Theorem]
		Let \(p\) be a prime. For any integer \(a\),
		\[
		a^p \equiv a \pmod{p}.
		\]
		Equivalently, if \(\gcd(a,p)=1\), then
		\[
		a^{p-1} \equiv 1 \pmod{p}.
		\]
		\label{thm:fermat_little_theorem}
	\end{theorem}
	
	\begin{theorem}[Euler's Theorem]
		For all \(a \in \mathbb{Z}_n^{(*)}\), we have
		\[
		a^{\phi(n)} \equiv 1 \pmod{n}.
		\]
		\label{thm:euler_theorem}
	\end{theorem}
	
	\begin{corollary}
		Let \(p\) and \(q\) be \emph{distinct} primes and let \(n=pq\). For any integer \(m\) with \(1 \le m < n\), we have
		\[
		m^{\phi(n)+1} \equiv m \pmod{n}.
		\]
		\label{thm:rsa_correctness}
	\end{corollary}
	\begin{proof}
		Let \(n=pq\), so \(\phi(n)=(p-1)(q-1)\). We prove the congruence modulo \(p\) and modulo \(q\), and then conclude modulo \(pq\).
		
		\medskip
		\noindent\textbf{Modulo \(p\).}
		If \(p\mid m\), then \(m\equiv 0 \pmod p\), hence \(m^{\phi(n)+1}\equiv 0 \equiv m \pmod p\).
		If \(p\nmid m\), then \(m^{p-1}\equiv 1 \pmod p\) (Fermat's little theorem). Since \(\phi(n)=(p-1)(q-1)\) is a multiple of \(p-1\), we get \(m^{\phi(n)}\equiv 1 \pmod p\), and multiplying by \(m\) gives
		\[
		m^{\phi(n)+1}\equiv m \pmod p.
		\]
		
		\medskip
		\noindent\textbf{Modulo \(q\).}
		The same argument applies. If \(q\mid m\), the congruence is trivial modulo \(q\). Otherwise, Fermat's little theorem gives \(m^{q-1}\equiv 1 \pmod q\), and since \(\phi(n)\) is a multiple of \(q-1\), we obtain
		\[
		m^{\phi(n)+1}\equiv m \pmod q.
		\]
		
		\medskip
		\noindent Since \(p\) and \(q\) are coprime, the Chinese Remainder Theorem implies that a congruence holding modulo \(p\) and modulo \(q\) holds modulo \(pq\) (see Lemma~\ref{lemma:crt_consequence}). Therefore,
		\[
		m^{\phi(n)+1}\equiv m \pmod{pq}.
		\]
		
		\medskip
		\noindent Also, if \(\gcd(n=pq, m) = 1\), then by Euler's theorem
		\[
		m^{\phi(n)+1}\equiv m \pmod{pq}.
		\]
	\end{proof}
	
	\begin{definition}[Quadratic Residue and Modular Square Root]
		An integer \(q\) is a quadratic residue modulo \(n\) if it is congruent to a perfect square modulo \(n\); that is, there exists an integer \(x\) such that
		\[
		x^2 \equiv q \pmod{n}.
		\]
		Any such \(x\) is called a (modular) square root of \(q\) modulo \(n\).
		\label{def:quadratic-residue}
	\end{definition}
	
	\begin{definition}[Legendre Symbol]
		Let \(p\) be an odd prime and \(\alpha\in\mathbb{Z}\). The Legendre symbol is
		\[
		\Bigl(\frac{\alpha}{p}\Bigr)=
		\begin{cases}
			0 & \text{if } p\mid \alpha,\\
			1 & \text{if } p\nmid \alpha \text{ and \(\alpha\) is a quadratic residue mod \(p\),}\\
			-1 & \text{if } p\nmid \alpha \text{ and \(\alpha\) is a quadratic nonresidue mod \(p\).}
		\end{cases}
		\]
		\label{def:legendre_sym}
	\end{definition}
	
	\begin{theorem}[Euler's Criterion]
		Let \(p\) be an odd prime and let \(\alpha\in\mathbb{Z}\) with \(p\nmid \alpha\). Then
		\[
		\Bigl(\frac{\alpha}{p}\Bigr)\equiv \alpha^{(p-1)/2} \pmod{p}.
		\]
		In words, \(\alpha\) is a quadratic residue modulo \(p\) iff \(\alpha^{(p-1)/2} \equiv 1 \pmod{p}\),
		and \(\alpha\) is a quadratic nonresidue modulo \(p\) iff \(\alpha^{(p-1)/2} \equiv -1 \pmod{p}\).
		\label{thm:euler_crit}
	\end{theorem}
	
	\subsection{Intractable Problems}
	The main intuition behind many ``intractable'' problems in public-key cryptography is captured by the notion of a \emph{trapdoor one-way function}. Informally, a publicly known function \(f\) is called a trapdoor one-way function if \(f(x)\) is efficiently computable for a given \(x\), but given \(y=f(x)\) it is computationally infeasible to recover a preimage \(x\) \emph{unless} some secret information (the \emph{trapdoor}) is known. While the formal definition is omitted here, the key idea remains: we build encryption/decryption mechanisms from problems that are believed to be computationally hard.
	
	\paragraph{Integer Factorization Problem (IFP).}
	Given a large positive composite integer \(N\), the Fundamental Theorem of Arithmetic guarantees that \(N\) factors uniquely into primes (up to order). The IFP asks us to compute the prime factorization of \(N\). In the cryptographic setting, the common situation is \(N=pq\) where \(p\) and \(q\) are large primes: it is easy to compute \(N\) from \((p,q)\), but (as far as current classical algorithms are concerned) recovering \((p,q)\) from \(N\) is believed to be infeasible for sufficiently large parameters. In this sense, knowing the factorization (i.e., knowing \(p\) and \(q\)) plays the role of the ``trapdoor''.
	
	\paragraph{Discrete Logarithm Problem (DLP).}
	Consider the multiplicative group \(\mathbb{Z}_p^{(*)}\) for a prime \(p\). This group is cyclic: there exists a generator \(g\in \mathbb{Z}_p^{(*)}\) such that
	\[
	\mathbb{Z}_p^{(*)}=\{g^0=1,g^1,g^2,\dots,g^{p-2}\}\quad (\text{all arithmetic modulo }p).
	\]
	Such a generator is called a \emph{primitive root modulo \(p\)}. A standard way to test whether a candidate \(g\) is a generator is to factor \(\phi(p) = p-1\) and check that
	\[
	g^{(p-1)/q_i}\not\equiv 1 \pmod p
	\quad\text{for every prime factor } q_i \text{ of } (p-1).
	\]
	(Equivalently, \(g\) has multiplicative order \(p-1\).) 
	For example, one generator of \(\mathbb{Z}_{97}^{(*)}\) is \(g=5\).
	
	The DLP is then: given \(p\), a generator \(g\in \mathbb{Z}_p^{(*)}\), and an element \(y\in \mathbb{Z}_p^{(*)}\), find an integer \(x\) (with \(0\le x \le p-2\)) such that
	\[
	y \equiv g^x \pmod p.
	\]
	This problem is believed to be computationally infeasible for appropriate choices of \(p\) and the underlying group parameters.
	
	\noindent Another interesting problem is the following, which is closely related to IFP (and, in particular, factoring can be reduced to it).
	
	\paragraph{Order-Finding Problem.}
	Given two positive integers \(x\) and \(N\) (with \(1<x<N\)) such that \(\gcd(x,N)=1\), we say that \(r\) is the \emph{order} of \(x \pmod N\) if it is the least positive integer such that
	\[
	x^r \equiv 1 \pmod N.
	\]
	The order-finding problem asks us to compute this \(r\).
	
	\begin{theorem}[Reduction from IFP to Order-Finding]
		Given an algorithm that computes \(\operatorname{ord}_N(x)\) for inputs \(x\) coprime to \(N\), one can factor a composite integer \(N\) (with high probability) by making a few calls to the order-finding algorithm.
	\end{theorem}
	
	\begin{proof}
		We first prove a basic claim that turns an appropriate congruence into a non-trivial factor.
		
		\medskip
		\noindent\textbf{Claim.}
		Let \(N\) be composite. If \(x^2 \equiv 1 \pmod N\) and \(x \not\equiv \pm 1 \pmod N\) (i.e., not trivial square roots of \(1\)), then
		\[
		\gcd(x-1,N)\quad\text{and}\quad \gcd(x+1,N)
		\]
		are non-trivial factors of \(N\).
		
		\noindent\emph{Proof of the claim.}
		From \(x^2\equiv 1 \pmod N\), we get
		\[
		x^2-1 \equiv 0 \pmod N
		\quad\Longrightarrow\quad
		(x-1)(x+1)\equiv 0 \pmod N,
		\]
		so \(N\mid (x-1)(x+1)\). If \(\gcd(x-1,N)=1\), then \(x-1\) is invertible modulo \(N\) (by Bézout's identity); since
		\((x-1)(x+1)\equiv 0 \pmod N\), multiplying both sides by \((x-1)^{-1}\) gives
		\(x+1\equiv 0 \pmod N\), i.e., \(x\equiv -1\pmod N\), contradicting the assumption.
		Hence \(\gcd(x-1,N)\neq 1\). Similarly, \(\gcd(x+1,N)\neq 1\).
		Also, \(\gcd(x-1,N)\neq N\) because that would imply \(x\equiv 1\pmod N\), and \(\gcd(x+1,N)\neq N\) because that would imply \(x\equiv -1\pmod N\). Therefore both gcds lie strictly between \(1\) and \(N\), giving non-trivial factors. \(\blacksquare\)
		
		\medskip
		\noindent Now we show how order-finding yields such an \(x\). Pick an integer \(y\) with \(1<y<N\) and compute \(d=\gcd(y,N)\).
		If \(d>1\), we have already found a non-trivial factor of \(N\), so we are done. Otherwise \(\gcd(y,N)=1\), and we can ask the order-finding algorithm for
		\[
		r=\operatorname{ord}_N(y),
		\quad\text{so that}\quad
		y^r\equiv 1\pmod N.
		\]
		If \(r\) is odd, then we try a different \(y\).
		If \(r\) is even, set \(x := y^{r/2}\pmod N\). Then
		\[
		x^2 \equiv y^r \equiv 1 \pmod N.
		\]
		If \(x \equiv -1 \pmod N\) (i.e., \(x \equiv N-1 \pmod N\)), then \(x\) is the ``trivial'' square root of \(1\) and the claim does not help, so we try a different \(y\).
		Otherwise, \(x\not\equiv \pm 1 \pmod N\), and the claim implies that
		\[
		\gcd(x-1,N)\quad\text{and}\quad \gcd(x+1,N)
		\]
		are non-trivial factors of \(N\).
		
		\medskip
		We are done and the only ``failure'' cases are when \(r\) is odd or when \(y^{r/2}\equiv -1\pmod N\), in which case we rerun with a new \(y\). 
	\end{proof}
	
	\newpage
	
	\section{Asymmetric-Key Cryptography Algorithms}
	In this section, descriptions of public-key algorithms based on the aforementioned intractable problems are given.
	
	\subsection{Algorithms based on IFP}
	\begin{algorithm}[H]
		\caption{\textsc{RSA Algorithm}}
		\label{algo:rsa}
		
		\textsc{RSA Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select two large (distinct) primes uniformly at random: \(p\) and \(q\).
			\STATE Compute the modulus \(N = pq\); note that \(\phi(N) = (p-1)(q-1)\).
			\STATE Select an encryption exponent \(e\) such that \(1 < e < \phi(N)\) and \(\gcd(e,\phi(N))=1\).
			\STATE Find the decryption exponent \(d\) by computing the multiplicative inverse of \(e\) modulo \(\phi(N)\) via Algorithm~\ref{alg:ext_euclid_algo}; i.e.,
			\[
			ed \equiv 1 \pmod{\phi(N)} \qquad \Leftrightarrow \qquad d \equiv e^{-1} \pmod{\phi(N)}.
			\]
			\STATE Publish the public key \(P_u=\{e,N\}\), and keep the private key \(S_u=\{d,p,q\}\) secret.
		\end{algorithmic}
		
		\textsc{RSA Encryption:}
		\begin{algorithmic}[1]
			\REQUIRE Obtain the recipient's public key \(P_u\).
			\STATE For a message representative \(M\) with \(0 \le M < N\), compute the ciphertext
			\[
			C = M^{e} \bmod N.
			\]
			\paragraph{Remark.} The message representative must satisfy \(0 \le M < N\). In practice, long messages are encoded into blocks.
		\end{algorithmic}
		
		\textsc{RSA Decryption:}
		\begin{algorithmic}[1]
			\REQUIRE The recipient possesses the private key \(S_u\).
			\STATE Recover the message representative by
			\[
			M = C^d \bmod N.
			\]
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.}
		Since \(ed \equiv 1 \pmod{\phi(N)}\), there exists an integer \(k\) such that
		\[
		ed = k\phi(N)+1.
		\]
		Then, using \(C \equiv M^e \pmod N\), we obtain
		\[
		C^d \equiv (M^e)^d = M^{ed} = M^{k\phi(N)+1} \pmod N.
		\]
		If \(\gcd(M,N)=1\), Euler's theorem (Theorem~\ref{thm:euler_theorem}) gives \(M^{\phi(N)}\equiv 1 \pmod N\), hence \(M^{k\phi(N)+1}\equiv M \pmod N\).
		If \(\gcd(M,N)\neq 1\), the same conclusion still holds when \(N=pq\) with \(p,q\) primes (by Corollary~\ref{thm:rsa_correctness}: \(m^{\phi(N)+1}\equiv m \pmod N\)). Therefore, in all cases,
		\[
		C^d \equiv M \pmod N,
		\]
		so decryption recovers the original message representative.
		
		\textbf{Remark.}
		RSA is commonly presented as being \emph{based on} the hardness of factoring \(N=pq\). If one can compute \(\phi(N)\) for \(N=pq\), then one can factor \(N\). Indeed,
		\[
		\phi(N) = (p-1)(q-1) = pq - (p+q) + 1 = N - (p+q) + 1,
		\]
		so
		\[
		p+q = N + 1 - \phi(N).
		\]
		Given \(N\) (which is made public) and \(p+q\) (can be computed from \(\phi(N)\)), the primes \(p\) and \(q\) are the two roots of
		\[
		X^2 - (p+q)X + N = 0,
		\]
		and can therefore be recovered efficiently. Thus, finding \(\phi(N)\) (or equivalently being able to compute \(d\) from \(e\) without the trapdoor information) is at least as hard as factoring \(N\).
	\end{analysis}
	
	\begin{algorithm}[H]
		\caption{\textsc{Rabin Algorithm}}
		\label{algo:rabin}
		\textsc{Rabin Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select two large (distinct) primes uniformly at random: \(p\) and \(q\).
			\STATE Compute the modulus \(N = pq\).
			\STATE Publish the public key \(P_u = \{N\}\), and keep the private key \(S_u = \{p,q\}\) secret.
		\end{algorithmic}
		
		\textsc{Rabin Encryption:}
		\begin{algorithmic}[1]
			\REQUIRE Obtain the recipient's public key \(P_u\).
			\STATE For a message representative \(M\) with \(0 \le M < N\), compute the ciphertext
			\[
			C = M^2 \bmod N.
			\]
			\paragraph{Remark.} \(C\) is always a quadratic residue modulo \(N\).
		\end{algorithmic}
		
		\textsc{Rabin Decryption:}
		\begin{algorithmic}[1]
			\REQUIRE The recipient possesses the private key \(S_u\).
			\STATE Compute square roots of \(C \bmod p\): \(\pm m_p\) (i.e., \(m_p^2 \equiv C \pmod p\)).
			\STATE Compute square roots of \(C \bmod q\): \(\pm m_q\) (i.e., \(m_q^2 \equiv C \pmod q\)).
			\STATE Find \(y_p\) and \(y_q\) such that \(y_p\cdot p + y_q\cdot q = 1\) using Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE Compute the following four candidates:
			\[
			m_1 = (y_p p\, m_q + y_q q\, m_p) \bmod N,\quad m_2 = (N - m_1) \bmod N,
			\]
			\[
			m_3 = (y_p p\, m_q - y_q q\, m_p) \bmod N,\quad m_4 = (N - m_3) \bmod N.
			\]
			\paragraph{Remark.} One of the \(m_i\) equals the original \(M\); without redundancy (e.g., padding), the decryption is ambiguous and no way to determine the original message representative.
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.} Since \(C \equiv M^2 \pmod{N=pq}\), it follows from Lemma~\ref{lemma:crt_consequence} that
		\[
		C \equiv M^2 \pmod p \quad \text{and} \quad C \equiv M^2 \pmod q,
		\]
		hence \(C\) has square roots modulo each prime. In particular, there exist \(m_p,m_q\) such that
		\[
		m_p^2 \equiv C \pmod p \quad \text{and} \quad m_q^2 \equiv C \pmod q,
		\]
		so the roots modulo the primes are 
		\[
		x \equiv \pm m_p \pmod p \quad\text{ and }\quad x \equiv \pm m_q \pmod q.
		\]
		
		Note that the hardness comes from the infeasibility of computing square roots modulo \(N\) directly without the factors. However, using the trapdoor \((p,q)\), we can combine roots modulo \(p\) and \(q\) using the procedure outlined in the Chinese Remainder Theorem (cf. Theorem~\ref{thm:chinese_remainder}). Concretely, compute coefficients via extended Euclidean algorithm:
		\[
		u_p \cdot q + v_p \cdot p = 1, \qquad u_q \cdot p + v_q \cdot q = 1.
		\]
		Reducing these congruences gives the inverses needed by the Chinese Remainder Theorem:
		\[
		u_p \cdot q \equiv 1 \pmod p \quad (\text{so } u_p \equiv q^{-1} \pmod p),
		\]
		\[
		u_q \cdot p \equiv 1 \pmod q \quad (\text{so } u_q \equiv p^{-1} \pmod q).
		\]
		(Equivalently, if you instead compute \(y_p,y_q\) such that \(y_p p + y_q q = 1\), then \(y_q \equiv q^{-1} \pmod p\) and \(y_p \equiv p^{-1} \pmod q\), so you may take \(u_p=y_q\) and \(u_q=y_p\) up to reduction.)
		
		Then, 
		\[ 
		x = \Bigl((\pm m_p)\cdot u_p \cdot q + (\pm m_q) \cdot u_q \cdot p\Bigr) \bmod N.
		\]
		
		Writing them explicitly (with representatives in \([0,N)\)) yields four solutions (one for each choice of signs \((\pm m_p,\pm m_q)\)), and we may denote:
		\[
		m_1 \equiv (\,m_p\, u_p\, q + m_q\, u_q\, p\,) \pmod N,
		\]
		\[
		m_3 \equiv (\,m_p\, u_p\, q - m_q\, u_q\, p\,) \pmod N,
		\]
		and the remaining two are their negations modulo \(N\):
		\[
		m_2 \equiv -m_1 \pmod N, \qquad m_4 \equiv -m_3 \pmod N.
		\]
		To see why this becomes \(N-m_i\) in the algorithmic form, take \(m_1\) as an example. By construction,
		\[
		m_1 \equiv m_p \pmod p,\qquad m_1 \equiv m_q \pmod q.
		\]
		Then
		\[
		-m_1 \equiv -m_p \pmod p,\qquad -m_1 \equiv -m_q \pmod q,
		\]
		so \(-m_1 \pmod N\) corresponds exactly to flipping both signs \((m_p,m_q)\mapsto(-m_p,-m_q)\). If we choose the standard representative in \([0,N)\), then
		\[
		-m_1 \bmod N =
		\begin{cases}
			0 & \text{if } m_1=0,\\
			N-m_1 & \text{otherwise,}
		\end{cases}
		\]
		which explains the assignments \(m_2 = (N-m_1)\bmod N\) and similarly \(m_4 = (N-m_3)\bmod N\).
		
		Hence, one of the four values \(m_1,m_2,m_3,m_4\) is the original \(M\).
	\end{analysis}
	
	\subsection{Algorithms based on DLP}
	\begin{algorithm}[H]
		\caption{\textsc{Diffie--Hellman Key Exchange Protocol}}
		\label{algo:diffie_hellman}
		\begin{algorithmic}[1]
			\REQUIRE User A and user B agree on a large prime \(p\) and a generator \(g\) of the cyclic multiplicative group \(\mathbb{Z}^{(\ast)}_p\).
			\STATE User A randomly chooses a secret exponent \(a \in \{1,2,\dots,p-2\}\), and sends \(A = g^a \bmod p\) to user B.
			\STATE User B randomly chooses a secret exponent \(b \in \{1,2,\dots,p-2\}\), and sends \(B = g^b \bmod p\) to user A.
			\STATE User A computes \(K = B^a \bmod p\), whereas user B computes \(K = A^b \bmod p\); since \(B^a \equiv (g^b)^a \equiv g^{ab} \equiv (g^a)^b \equiv A^b \pmod p\), they obtain the same shared secret \(K\).
			
			\paragraph{Remark.} Diffie--Hellman is a \emph{key agreement} protocol (not an encryption scheme by itself). Its security relies on the difficulty of the (computational) DLP in the chosen group. In practice, \(K\) is typically passed through a KDF (e.g., a hash) to derive a symmetric key, which can then be used with a symmetric-key scheme such as AES.
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{\textsc{ElGamal Algorithm}}
		\label{algo:elgamal}
		\textsc{ElGamal Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select a large prime \(p\) along with a generator \(g\) of the group \(\mathbb{Z}^{(\ast)}_p\).
			\STATE Select a secret exponent \(x \in \{1,2,\dots,p-2\}\) and compute \(y = g^x \bmod p\).
			\STATE Publish the public key \(P_u = \{p,g,y\}\), and keep the private key \(S_u = \{x\}\) secret.
		\end{algorithmic}
		
		\textsc{ElGamal Encryption:}
		\begin{algorithmic}[1]
			\REQUIRE Obtain the recipient's public key \(P_u\).
			\STATE For a message representative \(M \in \mathbb{Z}^{(\ast)}_p\), select a fresh random exponent \(r \in \{1,2,\dots,p-2\}\) and compute
			\[
			A = g^r \bmod p \quad\text{and}\quad B = M\cdot y^r \bmod p,
			\]
			thus the ciphertext is
			\[
			C = (A,B).
			\]
		\end{algorithmic}
		
		\textsc{ElGamal Decryption:}
		\begin{algorithmic}[1]
			\REQUIRE The recipient possesses the private key \(S_u\).
			\STATE Compute \(K = A^x \bmod p\), and determine the multiplicative inverse of \(K\) modulo \(p\) (i.e., \(K^{-1} \pmod p\)) using Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE Recover the message representative by
			\[
			M = B \cdot K^{-1} \bmod p.
			\]
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.} Since \(A \equiv g^r \pmod p\), it follows that
		\[
		K \equiv A^x \equiv (g^r)^x \equiv g^{rx} \pmod p,
		\]
		hence \(K^{-1} \equiv (g^{rx})^{-1} \pmod p\).
		Moreover, \(B \equiv M\cdot y^r \pmod p\) and \(y \equiv g^x \pmod p\), so
		\[
		B \equiv M\cdot (g^x)^r \equiv M\cdot g^{rx} \pmod p.
		\]
		Therefore,
		\[
		B\cdot K^{-1} \equiv (M\cdot g^{rx})\cdot (g^{rx})^{-1} \equiv M \pmod p,
		\]
		which recovers the original message representative.
	\end{analysis}
	
	\section{Digital Signatures}
	A \emph{digital signature} scheme produces a short string (the \emph{signature}) that binds a message to its alleged signer. Concretely, a signer uses a private (signing) key to generate a signature on a message, and anyone holding the corresponding public (verification) key can check whether the signature is valid. A correct and secure signature scheme provides \emph{authenticity} and \emph{integrity} of the signed message; in many practical settings, it is also used to support \emph{non-repudiation}. 
	
	Many public-key primitives (i.e., RSA, Rabin, and ElGamal) can be adapted to give signature schemes. Broadly, signature schemes are commonly classified into two categories: (i) \emph{message recovery} schemes, where the message can be recovered from the signature, and (ii) \emph{appendix} schemes, where the signature is transmitted alongside the message.
	
	\subsection{Message Recovery Schemes}
	\begin{algorithm}[H]
		\caption{\textsc{RSA Signature Scheme}}
		\label{algo:rsa_sig}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Generate the public key \(P_u=\{e,N\}\) and the associated private key \(S_u=\{d,p,q\}\) according to \textsc{RSA Key Generation} (cf. Algorithm~\ref{algo:rsa}).
		\end{algorithmic}
		
		\textsc{Signature Generation:}
		\begin{algorithmic}[1]
			\REQUIRE Signer possesses private key \(S_u\).
			\STATE For a message representative \(m\) with \(0 \le m < N\), compute
			\[
			m_r = R(m),
			\]
			where \(R(\cdot)\) is a publicly specified \emph{invertible redundancy/encoding function} \(R:M \to M_S\), with \(M_S \subseteq \{0,1,\dots,N-1\}\) denoting the set of valid encoded representatives (so \(m_r\) is an integer representative modulo \(N\)).
			\STATE Compute the signature (with embedded message representative)
			\[
			\sigma = (m_r)^d \bmod N.
			\]
			\COMMENT{Only the signer knows \(d\).}
		\end{algorithmic}
		
		\textsc{Signature Verification:}
		\begin{algorithmic}[1]
			\REQUIRE Verifier has the public key \(P_u\).
			\STATE Compute \(m_r = (\sigma)^e \bmod N\) and verify that \(m_r \in M_S\) (if not, reject).
			\STATE Recover the message representative by
			\[
			m = R^{-1}(m_r).
			\]
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{\textsc{Rabin Signature Scheme}}
		\label{algo:rabin_sig}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Generate the public key \(P_u=\{N\}\) and the associated private key \(S_u=\{p,q\}\) according to \textsc{Rabin Key Generation} (cf. Algorithm~\ref{algo:rabin}).
		\end{algorithmic}
		
		\textsc{Signature Generation:}
		\begin{algorithmic}[1]
			\REQUIRE Signer possesses private key \(S_u\).
			\STATE For a message representative \(m\) with \(0 \le m < N\), compute an encoded representative \(m_r = R(m)\) such that \(m_r\) is a quadratic residue modulo \(N\).
			\STATE Compute a square root \(\sigma\) of \(m_r\) modulo \(N\); i.e., find \(\sigma\) such that
			\[
			\sigma^2 \equiv m_r \pmod N,
			\]
			and output the signature with embedded message representative, \(\sigma\). Also, make \(R(\cdot)\) public.
			
			\paragraph{Remark.} Only the signer can compute square roots modulo \(N\) efficiently, since this is feasible given the trapdoor factors \((p,q)\).
		\end{algorithmic}
		
		\textsc{Signature Verification:}
		\begin{algorithmic}[1]
			\REQUIRE Verifier has the public key \(P_u\).
			\STATE Compute \(m_r = \sigma^2 \bmod N\) and verify that \(m_r\) is a valid encoding (i.e., \(m_r \in M_S\), the range of \(R\)); if not, reject.
			\STATE Recover the message representative by
			\[
			m = R^{-1}(m_r).
			\]
		\end{algorithmic}
	\end{algorithm}
	
	\subsection{Appendix Schemes}
	In an \emph{appendix} signature scheme, the signature is transmitted alongside the message (i.e., it is not intended to allow message recovery from the signature alone). Typically, this is done with the help of a cryptographically secure hash function \(H(\cdot)\), such as \texttt{SHA-256}. The message is first processed by \(H\) to produce a fixed-length string called a \emph{message digest}, and the signer then signs this digest.
	
	To verify, the verifier recomputes the digest of the received message using the same hash function and uses the signer’s public key to check whether the signature is valid for that digest; the message is accepted only if the check succeeds. This emphasizes that the purpose of digital signatures is not confidentiality, but \emph{authentication} and \emph{integrity}. The integrity guarantee relies on the collision resistance of \(H\): it should be computationally infeasible to find two different messages that produce the same digest.
	
	\begin{algorithm}[H]
		\caption{\textsc{ElGamal Signature Scheme}}
		\label{algo:elgamal_sig}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Generate the public key \(P_u = \{p,g,y\}\) and the associated private key \(S_u = \{x\}\) according to \textsc{ElGamal Key Generation} (cf. Algorithm~\ref{algo:elgamal}).
		\end{algorithmic}
		\textsc{Signature Generation:}
		\begin{algorithmic}[1]
			\REQUIRE Signer possesses private key \(S_u\).
			\STATE Select a random \(k\) such that \(1 \le k \le p-2\) and \(\gcd(k,p-1)=1\) (we do not choose \(k=0\) because it is trivial).
			\STATE Compute \(r = g^k \bmod p\); and find \(k^{-1} \pmod{p-1}\) via Algorithm~\ref{alg:ext_euclid_algo} (this is because the exponent is residue modulo \(p-1\)).
			\STATE For a message representative \(m\), compute the digest \(H(m)\).
			\STATE Compute
			\[
			s = k^{-1}\cdot (H(m)-xr) \bmod (p-1),
			\]
			where \(H(\cdot)\) is a secure hash function. \COMMENT{Only the signer knows \(x\).}
			\STATE Output the signature (to be appended alongside the message representative during transmission)
			\[
			\sigma = (r,s).
			\]
		\end{algorithmic}
		\textsc{Signature Verification:}
		\begin{algorithmic}[1]
			\REQUIRE Verifier has the public key \(P_u\).
			\STATE Verify that \(1 \le r \le p-1\) and \(0 \le s \le p-2\) (if not, reject).
			\STATE Compute
			\[
			v_1 = y^r \cdot r^s \bmod p.
			\]
			\STATE Using the same secure hash function, compute \(H(m)\) and evaluate
			\[
			v_2 = g^{H(m)} \bmod p.
			\]
			\STATE Accept the message if and only if \(v_1 = v_2\).
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.} By construction,
		\[
		s \equiv k^{-1}\cdot (H(m)-xr) \pmod{p-1},
		\]
		and since \(\gcd(k,p-1)=1\), multiplying both sides by \(k\) and re-arranging terms yields
		\[
		H(m) \equiv ks + xr \pmod{p-1}.
		\]
		Since \(g\) is a generator of \(\mathbb{Z}^{(\ast)}_p\) (so exponent arithmetic is modulo \(p-1\)), we may exponentiate \(g\) on both sides to obtain the congruence modulo \(p\):
		\begin{align*}
			g^{H(m)} &\equiv g^{ks+xr} \pmod p\\
			&\equiv g^{ks}\cdot g^{xr} \pmod p\\
			&\equiv (g^k)^s \cdot (g^x)^r \pmod p\\
			&\equiv r^s \cdot y^r \pmod p.
		\end{align*}
		Thus \(g^{H(m)} \equiv y^r \cdot r^s \pmod p\), establishing \(v_1=v_2\) for the same message representative digest \(H(m)\).
	\end{analysis}
	
	We now look at an interesting standardized variant of the ElGamal signature scheme called the \emph{digital signature algorithm} (DSA).
	
	\begin{algorithm}[H]
		\caption{\textsc{DSA Signature Scheme}}
		\label{algo:dsa_sig}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select a large prime \(p\) at random.
			\STATE Choose a prime \(q < p\) such that \(q \mid (p-1)\).
			\STATE Choose an integer \(h\) with \(1 < h < p-1\) and compute
			\[
			\alpha = h^{(p-1)/q} \bmod p.
			\]
			\STATE If \(\alpha = 1\), repeat the previous step with a new \(h\).
			\paragraph{Remark.} \(\alpha\) generates a cyclic subgroup of \(\mathbb{Z}^{(\ast)}_p\) of order \(q\).
			\STATE Select a random \(x\) such that \(1 \le x \le q-1\) and compute
			\[
			y = \alpha^x \bmod p.
			\]
			\STATE Publish the public key \(P_u = \{p,q,\alpha,y\}\) and keep the private key \(S_u = \{x\}\) secret.
		\end{algorithmic}
		
		\textsc{Signature Generation:}
		\begin{algorithmic}[1]
			\REQUIRE Signer possesses private key \(S_u\).
			\STATE Select a random \(k\) such that \(1 \le k \le q-1\).
			\STATE Compute \(r = (\alpha^k \bmod p) \bmod q\). If \(r=0\), select a new \(k\) and repeat.
			\STATE Find \(k^{-1} \pmod q\) via Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE For a message representative \(m\), compute \(H(m)\) (reduced modulo \(q\)).
			\STATE Compute
			\[
			s = k^{-1}\cdot (H(m) + xr) \bmod q,
			\]
			where \(H(\cdot)\) is a secure hash function. \COMMENT{Only the signer knows \(x\).}
			\STATE If \(s=0\), select a new \(k\) and repeat.
			\STATE Output the signature (to be appended alongside the message representative during transmission)
			\[
			\sigma = (r,s).
			\]
		\end{algorithmic}
		
		\textsc{Signature Verification:}
		\begin{algorithmic}[1]
			\REQUIRE Verifier has the public key \(P_u\).
			\STATE Verify that \(0 < r < q\) and \(0 < s < q\) (if not, reject).
			\STATE Find \(\omega = s^{-1} \bmod q\) via Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE Using the same secure hash function, compute \(H(m)\) (reduced modulo \(q\)) and evaluate
			\[
			u_1 = \omega \cdot H(m) \bmod q \quad\text{and}\quad u_2 = \omega \cdot r \bmod q.
			\]
			\STATE Compute
			\[
			v = (\alpha^{u_1}\cdot y^{u_2} \bmod p)\bmod q.
			\]
			\STATE Accept the message if and only if \(v = r\).
		\end{algorithmic}
	\end{algorithm}
	
	\begin{analysis}
		\textbf{Correctness.} By construction,
		\[
		s \equiv k^{-1}\cdot (H(m) + xr) \pmod q,
		\]
		and since \(1 \le k \le q-1\) (so \(k\) is invertible modulo \(q\)), multiplying both sides by \(k\) and re-arranging the terms gives
		\[
		H(m) \equiv ks - xr \pmod q.
		\]
		It follows that
		\begin{align*}
			u_1 &\equiv \omega \cdot H(m) \pmod q\\
			&\equiv \omega \cdot (ks - xr) \pmod q\\
			&\equiv k - x(\omega r) \pmod q \quad \text{because \(\omega \equiv s^{-1} \pmod q\)}\\
			&\equiv k - xu_2 \pmod q,
		\end{align*}
		and thus
		\[
		u_1 + xu_2 \equiv k \pmod q.
		\]
		Since \(\alpha\) has order \(q\) in \(\mathbb{Z}^{(\ast)}_p\), we may exponentiate \(\alpha\) (modulo \(p\)) to obtain
		\[
		\alpha^{u_1}\cdot (\alpha^x)^{u_2} \equiv \alpha^k \pmod p.
		\]
		Using \(y \equiv \alpha^x \pmod p\), this implies
		\[
		(\alpha^{u_1}\cdot y^{u_2} \bmod p)\bmod q = v = (\alpha^k \bmod p)\bmod q = r,
		\]
		so \(v=r\) for the same representative digest \(H(m)\).
	\end{analysis}
	
	\section{Elliptic Curve Cryptography}
	Recall that for a chosen field \(\mathbb{F}\), we can describe an elliptic curve \(\mathsf{E}(\mathbb{F})\) whose points \((x,y) \in \mathbb{F}^2\)---along with the special point at infinity \(O\)---form an additive group denoted by \((\mathsf{E}(\mathbb{F}), +)\). Moreover, operations like point addition \(+\) and doubling depend on the choice of the elliptic curve (i.e., on the curve equation and the underlying field). The goal is to modify public-key primitives that utilize DLP (e.g., Diffie--Hellman, ElGamal, and DSA) by replacing the underlying intractable problem with the \emph{elliptic curve discrete logarithm problem} (ECDLP).
	
	\textbf{ECDLP.} Consider a finite field \(\mathbb{F}_q\) (in practice, \(q\) is a large prime or a power of \(2\)) and an elliptic curve \(\mathsf{E}\) defined over \(\mathbb{F}_q\). Then \(\mathsf{E}(\mathbb{F}_q)\) is a finite abelian group. Fix a base point \(G \in \mathsf{E}(\mathbb{F}_q)\) and let \(n\) denote its (group) order, i.e., the smallest positive integer such that
	\[
	n\cdot G = O.
	\]
	We work in the cyclic subgroup \(\langle G\rangle = \{x\cdot G : x \in \mathbb{Z}\}\) (and \(|\langle G \rangle| = n\)). The ECDLP asks: given \(\mathsf{E}(\mathbb{F}_q)\), \(G\), and a point \(Y \in \langle G\rangle\), find an integer \(x \in \{0,1,\dots,n-1\}\) such that
	\[
	Y = x \cdot G.
	\]
	
	\paragraph{Remark.} In \(\mathbb{Z}_p^{(\ast)}\), a ``generator'' \(g\) is typically a primitive root that generates the entire group (so \(\langle g\rangle=\mathbb{Z}_p^{(\ast)}\) and \(|\langle g\rangle|=p-1\)). In elliptic curve cryptography, the base point \(G\) may be any point on \(\mathsf{E}(\mathbb{F}_q)\) in the sense that it always defines a cyclic subgroup \(\langle G\rangle\); however, for cryptographic security one chooses \(G\) so that \(|\langle G\rangle|=n\) is large (typically prime or nearly prime).
	
	\begin{algorithm}[H]
		\caption{\textsc{EC Diffie--Hellman Key Exchange Protocol}}
		\label{algo:ec_diffie_hellman}
		\begin{algorithmic}[1]
			\REQUIRE User A and user B agree on a curve \(\mathsf{E}(\mathbb{F}_q)\) and a base point \(G \in \mathsf{E}(\mathbb{F}_q)\) that generates a large cyclic subgroup \(\langle G\rangle\). Let \(\mathsf{ord}(G)=n\).
			\STATE User A randomly chooses a secret integer \(a \in \{1,2,\dots,n-1\}\), and sends \(A = a\cdot G\) to user B.
			\STATE User B randomly chooses a secret integer \(b \in \{1,2,\dots,n-1\}\), and sends \(B = b\cdot G\) to user A.
			\STATE User A computes \(K = a\cdot B\), whereas user B computes \(K = b\cdot A\); since
			\[
			a\cdot B = a\cdot (b\cdot G) = (ab)\cdot G = (ba)\cdot G = b\cdot (a\cdot G) = b\cdot A,
			\]
			they obtain the same shared secret point \(K \in \langle G\rangle\).
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{\textsc{EC ElGamal Algorithm}}
		\label{algo:ec_elgamal}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select a curve \(\mathsf{E}(\mathbb{F}_q)\) along with a base point \(G \in \mathsf{E}(\mathbb{F}_q)\); define \(n := \mathsf{ord}(G)\).
			\STATE Select a secret integer \(x \in \{1,2,\dots,n-1\}\) and compute \(Y = x \cdot G\).
			\STATE Publish the public key \(P_u = \{\mathsf{E}(\mathbb{F}_q),G,Y\}\) and keep the private key \(S_u = \{x\}\) secret.
		\end{algorithmic}
		
		\textsc{Encryption:}
		\begin{algorithmic}[1]
			\REQUIRE Obtain the recipient's public key \(P_u\).
			\STATE Represent the message \(M\) as a point on the curve \(P_M \in \mathsf{E}(\mathbb{F}_q)\).
			\STATE Select a fresh random integer \(r \in \{1,2,\dots,n-1\}\), and compute
			\[
			A = r\cdot G \quad\text{and}\quad B = P_M + r\cdot Y,
			\]
			thus the ciphertext is
			\[
			C = (A,B).
			\]
		\end{algorithmic}
		
		\textsc{Decryption:}
		\begin{algorithmic}[1]
			\REQUIRE The recipient possesses the private key \(S_u\).
			\STATE Compute
			\[
			P_M = B - x\cdot A,
			\]
			and recover \(M\) from \(P_M\).
		\end{algorithmic}
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{\textsc{ECDSA}}
		\label{algo:ecdsa_sig}
		\textsc{Key Generation:}
		\begin{algorithmic}[1]
			\STATE Select a curve \(\mathsf{E}(\mathbb{F}_q)\) along with a base point \(G \in \mathsf{E}(\mathbb{F}_q)\) such that its order \(n\) is a large prime.
			\STATE Select a random integer \(x \in \{1,2,\dots,n-1\}\) and compute \(Y = x \cdot G\).
			\STATE Publish the public key \(P_u = \{\mathsf{E}(\mathbb{F}_q),G,n,Y\}\) and keep the private key \(S_u = \{x\}\) secret.
		\end{algorithmic}
		
		\textsc{Signature Generation:}
		\begin{algorithmic}[1]
			\REQUIRE Signer possesses private key \(S_u\).
			\STATE Select a random \(k \in \{1,2,\dots,n-1\}\), and compute the point
			\[
			(p_x,p_y) = k \cdot G.
			\]
			\STATE Compute \(r = p_x \bmod n\). If \(r=0\), select a new \(k\) and repeat.
			\STATE Find \(k^{-1} \pmod n\) via Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE For a message representative \(m\), compute
			\[
			s = k^{-1}\cdot (H(m) + xr) \bmod n,
			\]
			where \(H(\cdot)\) is a secure hash function (interpreted as an integer reduced modulo \(n\)).
			\STATE If \(s=0\), select a new \(k\) and repeat.
			\STATE Output the signature (to be appended alongside the message representative during transmission)
			\[
			\sigma = (r,s).
			\]
		\end{algorithmic}
		
		\textsc{Signature Verification:}
		\begin{algorithmic}[1]
			\REQUIRE Verifier has the public key \(P_u\).
			\STATE Verify that \(0 < r < n\) and \(0 < s < n\) (if not, reject).
			\STATE Find \(\omega = s^{-1} \bmod n\) via Algorithm~\ref{alg:ext_euclid_algo}.
			\STATE Using the same secure hash function, compute \(H(m)\) (as an integer reduced modulo \(n\)) and evaluate
			\[
			u_1 = \omega \cdot H(m) \bmod n \quad\text{and}\quad u_2 = \omega \cdot r \bmod n.
			\]
			\STATE Compute the point
			\[
			(p_x',p_y') = u_1 \cdot G + u_2 \cdot Y,
			\]
			and let \(v = p_x' \bmod n\).
			\STATE Accept the message if and only if \(v=r\).
		\end{algorithmic}
	\end{algorithm}
\end{document}